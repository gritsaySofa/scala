# scala
Задание 1:
Дана таблица 
Город отправления Город прибытия Номер борта Расстояние
Санкт-Петербург Екатеринбург 165 3078
Новосибирск Уфа 188 2512
Челябинск Геленджик 180 2800
Красноярск Геленджик 194 4300
Хабаровск Омск 166 4500
Москва Уфа 198 3200
Геленджик Омск 128 5000
Москва Красноярск 191 5700
Иркутск Рязань 170 8300
Саратов Грозный 104 1500
Екатеринбург Хабаровск 197 2850
Рязань Хабаровск 189 9000
Новосибирск Омск 128 1005
Санкт-Петербург Краснодар 182 2117
Санкт-Петербург Грозный 117 2300
Москва Новосибирск 153 4500
 Найдите номера всех бортов, вылетевших из Санкт-Петербурга
 Найти информацию обо всех рейсах, у которых расстояние выше среднего расстояния
 Найди рейс Москва- Уфа и замени номер борта на 777
 Получить подтаблицу, содержащую только столбцы Город прибытия, Номер борта
Задание 2: Используя RDD
1. В заданном файле RDD.txt подсчитать количество строк, подсчитать количество 
пустых строк, удалить пустые строки, посчитать количество вхождений заданного 
слова
2. Даны два списка типа ключ(string) –значение(int) (составить самостоятельно) 
длиной 3 и 5. Со списками проделать следующие действия:
 объединить 2 списка;
 агрегировать по ключу;
 сортировать в порядке убывания


import spark.implicits._
import org.apache.spark.sql.functions._ 


// 1) Создаём DataFrame из встроенных данных
val flightsDF = Seq(
  ("Санкт-Петербург","Екатеринбург",165,3078),
  ("Новосибирск","Уфа",188,2512),
  ("Челябинск","Геленджик",180,2800),
  ("Красноярск","Геленджик",194,4300),
  ("Хабаровск","Омск",166,4500),
  ("Москва","Уфа",198,3200),
  ("Геленджик","Омск",128,5000),
  ("Москва","Красноярск",191,5700),
  ("Иркутск","Рязань",170,8300),
  ("Саратов","Грозный",104,1500),
  ("Екатеринбург","Хабаровск",197,2850),
  ("Рязань","Хабаровск",189,9000),
  ("Новосибирск","Омск",128,1005),
  ("Санкт-Петербург","Краснодар",182,2117),
  ("Санкт-Петербург","Грозный",117,2300),
  ("Москва","Новосибирск",153,4500)
).toDF("from","to","num","dist")

// 1. Номера всех бортов, вылетевших из Санкт-Петербурга
println("Номера бортов из Санкт-Петербурга:")
flightsDF.filter($"from" === "Санкт-Петербург").select("num").as[Int].collect().foreach(println)

// 2. Информация о рейсах со расстоянием > среднего
val avgDist = flightsDF.agg(avg($"dist")).as[Double].first()
println(f"\nСреднее расстояние = $avgDist%.2f")
println("Рейсы с расстоянием > среднего:")
flightsDF.filter($"dist" > avgDist).show(false)

// 3. Замена номера борта на 777 для рейса Москва → Уфа

val updatedDF = flightsDF.withColumn("num",when($"from" === "Москва" && $"to" === "Уфа", lit(777)).otherwise($"num"))
println("\nОбновлённый рейс Москва → Уфа:")
updatedDF.filter($"from" === "Москва" && $"to" === "Уфа").show(false)

// 4. Подтаблица: только столбцы (Город прибытия, Номер борта)
println("\nПодтаблица (to, num):")
flightsDF.select($"to", $"num").show(false)



// Задание 2
val data = sc.textFile("info.txt")

// 2.1.1 Всего строк
val total = data.count()
// 2.1.2 Пустых строк
val empty = data.filter(_.trim.isEmpty).count()
// 2.1.3 Удалить пустые
val nonEmpty = data.filter(_.trim.nonEmpty)
// 2.1.4 Вхождения заданного слова
val word = "data"
val occurrences = data.flatMap(_.split("\\W+")).filter(_ == word).count()

println(f"\nВсего = $total%d, пустых = $empty%d, вхождений '$word' = $occurrences%d")

// 2.2 Два списка ключ–значение
val rdd1 = sc.parallelize(Seq(("key1",1), ("key2",2), ("key3",3)))
val rdd2 = sc.parallelize(Seq(("key2",4), ("key3",5), ("key4",6), ("key5",7), ("key6",8)))

// 2.2.1 Объединение:
println("\nОбъединение:")
val merged = rdd1.union(rdd2)
merged.collect().foreach(println)



// 2.2.2 Агрегация:
println("\nАгрегация:")
val aggregated = merged.reduceByKey(_ + _)
aggregated.collect().foreach(println)



// 2.2.3 Сортировка:
println("\nСортировка:")
val sortedDesc = aggregated.sortBy(_._2, ascending = false)
sortedDesc.collect().foreach(println)
